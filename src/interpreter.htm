<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Cachi‑Forth Interpreter</title>
  <style> 
    body{font-family:monospace;background:#111;color:#eee;padding:20px}
    textarea{width:100%;height:200px;background:#222;color:#0f0;border:1px solid #555;padding:10px;font-size:14px}
    button{margin:10px 10px 10px 0;padding:10px}
    #output{background:#222;padding:10px;border:1px solid #555;white-space:pre-wrap;color:#0ff}
    #graph{background:#000;border:1px solid #555;width:100%;height:120px;display:block;margin-top:6px}
    #history{margin-top:20px;padding:10px;background:#111;border-top:1px solid #555}
    .saved-entry{background:#222;margin-bottom:10px;padding:10px;border:1px solid #444;white-space:pre-wrap}
  </style>
</head>
<body>
  <h1>Cachi‑Forth Interpreter</h1>

  <textarea id="program" placeholder="Enter your Cachi‑Forth code..."></textarea><br>
  <button onclick="runProgram()">Run</button>
  <button onclick="generateRandomProgram()">Random</button>
  <button onclick="saveProgram()">Save</button>
  <button onclick="mutateProgram()">Mutate</button>
  <button onclick="clearSavedPrograms()">Clear</button>
  <button id="autoBtn" onclick="toggleAuto()">Start</button>
  <button onclick="computePerturbationIndex()">Calc Inertia</button>
  <button onclick="computeSelectedCost()">Calc Cost</button>
  <div style='margin-bottom: 10px;'>
&nbsp;Generation: <span id="mutCount">0</span>
&nbsp;|&nbsp;Inertia:&nbsp;<span id="inertiaVal">0</span>
  &nbsp;|&nbsp;Len: &nbsp;<span id="progLen">0</span>
&nbsp;|&nbsp;CC:&nbsp;<span id="ccVal">0</span>
&nbsp;|&nbsp;@last:&nbsp;<span id="lastCount">0</span>
    &nbsp;|&nbsp;Steps:&nbsp;<span id="stepCount">0</span>
    &nbsp;|&nbsp;Cost:&nbsp;<span id="cost">0</span>
  </div>
  <div id="output"></div>  
  <svg id="graph"></svg>
<div id="labelsArea">
  <h2>Labels</h2>
  <div id="labelsList" style="white-space:pre-wrap"></div>
</div>
  <div id="history">
    <h2>Saved Programs</h2>
    <div id="savedList"></div>
  </div>

<script>
/******************** CONSTANTS & HELPERS *********************/
const MAX_INST = 2000;
const ANCHOR_STEPS = 25;
const CLAMP = v => ((v % 128) + 128) % 128;
let LABELS = {};   // label-string  -> tokenIndex (-1 = missing)

let autoTimer   = null;   // holds setInterval handle
let mutCount    = 0;      // shown in UI
const STEP_MS   = 200;    // mutation cadence (adjust to taste)
let stepCount = 0;
let stepPeg = 0;
let bitCounter = 0;
let outputHistory = [];
let outputInertia = [];
let targetSteps = 0;
let outputColorHistory = [];
let outputTitleHistory = [];
const PERTURBATION_RUNS = 100;
const PI_TOTAL_TIMEOUT_MS = 8000; // total time cap for a full PI computation
const PI_MIN_TRIALS = 10;         // require at least this many samples per side
	
const splitTok = t => {
	if (t==null) return [ "", "" ];
  const idx = t.indexOf(':');
  return idx === -1 ? [t, null] : [t.slice(0, idx), t.slice(idx + 1)];
};

// Helpers to classify tokens and generate command tokens
const isNumberToken = (tok) => {
  const [base] = splitTok(tok);
  return /^-?\d+$/.test(base);
};
const isCommandToken = (tok) => !isNumberToken(tok);
function randNonNumberToken(valid = funcNames) {
  let t;
  do {
    t = randToken(valid);
  } while (isNumberToken(t));
  return t;
}

const isControl = (tok) => {
  const [b] = splitTok(tok);
  return b === "loop" || b === "ifg" || b === "ifl" ||
         b.startsWith("@") ||                      // function call
         (b.startsWith("branch") && b.length === 7);
};

function hashCode(str) {
	let h = 0; 
	for (let i = 0; i < str.length; i++) {
		h = ((h << 5) - h) + str.charCodeAt(i);
		h |= 0;
	}
	return h;
}

function levenshtein(a, b) {
	const m = a.length,
		n = b.length,
		dp = Array.from({
			length: m + 1
		}, () => Array(n + 1));
	for (let i = 0; i <= m; i++) dp[i][0] = i;
	for (let j = 0; j <= n; j++) dp[0][j] = j;
	for (let i = 1; i <= m; i++)
		for (let j = 1; j <= n; j++) dp[i][j] = a[i - 1] === b[j - 1] ? dp[i - 1][j - 1] : 1 + Math.min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]);
	return dp[m][n];
}

/******************** TOKEN POOLS *********************/
const instrPool = ["+", "-", "*", "/", "dup", "swap", "bit", "bval", "out", "prune"];
const ctrlPool = ["loop", "ifg", "ifl", "branch2", "branch3", "branch4", "branch5"];
const funcNames = ["func1", "func2", "func3", "func4", "func5"];

/******************** RANDOM TOKEN / PROGRAM *********************/
function randToken(valid = funcNames){
  const r = Math.random();
  // 50% chance: literal number
  if(r < 0.5) return (Math.floor(Math.random()*256) - 127).toString();
  // 25% chance: common ops with heavier weight on `out`
  if(r < 0.75){
    const fav = ["dup","swap","bit", "bval", "@random", "@time", "drop","out","out","out", "@last", "prune", "prune"];
    return fav[Math.floor(Math.random()*fav.length)];
  }
  // 25% chance: control / function tokens
  const branchTokens = ["branch2","branch3","branch4"]; // restrict to branch2‑4
  const controlTokens = ["loop","ifg","ifl",...branchTokens];
  // Limit function space to first 3 names to keep total distinct functions small
  const limitedFuncs = valid.slice(0,3);
  const pool = [
    ...instrPool,                 // + - * /
    ...controlTokens,             // loop / ifg / ifl / branch2‑4
    ...limitedFuncs.map(f => "@"+f),  // function calls (max 3)
    ...limitedFuncs.map(f => ">"+f),  // declarations (max 3)
    "end"                         // explicit end token
  ];
  return pool[Math.floor(Math.random()*pool.length)];
}
function generateRandomProgram() {
	mutCount = 0;
	updateMutCount();
	inertiaVal = 0;
	inertiaHist = [];
	updateInertia();
	if (autoTimer) toggleAuto();   // ensure auto-evolve halts on Clear

	const tot = 50,
		numFuncs = Math.floor(Math.random() * 4) + 1,
		active = funcNames.slice(0, numFuncs);
	const defs = [];
	for (const name of active) {
		defs.push(`>${name} ${randToken(active)} ${randToken(active)} ${randToken(active)} end`);
	}
	const toks = [];
	while (toks.length < tot - defs.join(" ").split(/\s+/).length - 2) toks.push(randToken(active));
	toks.push("out", "end");
	document.getElementById("program").value = defs.join("\n") + "\n" + toks.join(" ");
	runProgram();
}

  function getMetrics (tokenArr) {
  let cc = 1;                       // baseline path
  let lastCount = 0;                // count of @last commands
  for (const t of tokenArr) {
    const [base] = splitTok(t);
    if (base === "loop" || base === "ifg" || base === "ifl") cc += 1;
    else if (base.startsWith("branch") && base.length === 7) {
      const n = +base[6];
      if (n >= 2 && n <= 5) cc += n - 1;  // branch2 ⇒ +1, branch3 ⇒ +2 …
    }
    else if (base === "@last") lastCount += 1;  // count @last commands
  }
  return { len: tokenArr.length, cc, lastCount };
}

function updateMetricsView (len, cc, lastCount) {
  const lEl = document.getElementById("progLen");
  const cEl = document.getElementById("ccVal");
  const lastEl = document.getElementById("lastCount");
  document.getElementById("stepCount").textContent = stepCount;
  document.getElementById("cost").textContent = (len * stepCount);
  if (lEl) lEl.textContent = len;
  if (cEl) cEl.textContent = cc;
  if (lastEl) lastEl.textContent = lastCount || 0;
}

function updateMutCount () {
  const el = document.getElementById("mutCount");
  if (el) el.textContent = mutCount;
}

let inertiaVal = 0;                // last-measured inertia (resistance to change)
const INERTIA_WINDOW = 20;        // size of the rolling window (last ~20 values)
let   inertiaHist = [];        // holds the most-recent values
	
function updateInertia () {        // refresh the UI
  // compute mean of the window (default 0 if empty)
  const mean = inertiaHist.length
        ? inertiaHist.reduce((s,v) => s + v, 0) / inertiaHist.length
        : 0;

  const el = document.getElementById("inertiaVal");
  if (el) el.textContent = mean.toFixed(1);      // one-decimal display
}

function toggleAuto () {
  const btn = document.getElementById("autoBtn");
  if (!btn) return;

  if (autoTimer) {                 // ----- STOP -----
    clearInterval(autoTimer);
    autoTimer = null;
    targetSteps = 0;
    btn.textContent = "Start";
    return;
  }

  // ----- START -----
  btn.textContent = "Stop";
  targetSteps = stepCount;
  autoTimer = setInterval(() => {
    const lost = Object.values(LABELS).some(v => v === -1);
    if (lost) {                    // stop if any label vanished
      toggleAuto();
      return;
    }
    mutateProgram();               // perform one mutation
    mutCount++;
    updateMutCount();
  }, STEP_MS);
}

function updateLabelsView () {
  const list = document.getElementById("labelsList");
  if (!list) return;

  const html = Object.keys(LABELS)
    .sort()                                    // alphabetical for stability
    .map(k => {
      const v = LABELS[k];
      const col = v === -1 ? "#f44" : "#eee";  // red if missing
      return `<span style="color:${col}">${k}:${v}</span>`;
    })
    .join("  ");                               // two nbsp’s for spacing

  list.innerHTML = html;
}
/******************** GRAPH RENDER *********************/
function drawGraph(vals, cols, titles) {
	const svg = document.getElementById("graph");
	if (!svg) return;

	const histories = outputHistory;
	const inertias = outputInertia;
  const colorHist = outputColorHistory;
	if (!histories.length) {
		svg.innerHTML = "";
		svg.style.height = "0px";
		return;
	}

	const W = svg.clientWidth || 600;
	const BASE_H = 30;     // height for inertia in [1..10]
	const MIN_H  = 5;      // minimum row height for very high inertia
	const GAP    = 1;      // gap between rows
	const TAU    = 40;     // decay constant controlling how fast height shrinks

	function heightFromInertia(inertia) {
		if (!inertia || inertia <= 10) return BASE_H;
		if (inertia >= 150) return MIN_H;
		const decay = Math.exp(-(inertia - 10) / TAU);
		return Math.max(MIN_H, MIN_H + (BASE_H - MIN_H) * decay);
	}

	let y = 0;
	let g = "";
	// Draw newest at the top, older moving down
	for (let idx = histories.length - 1; idx >= 0; idx--) {
		const rowVals = histories[idx] || [];
		const inertia = inertias[idx] ?? 0;
    const rowCols = (colorHist && colorHist[idx]) || [];
		const rowH = heightFromInertia(inertia);
		const n = rowVals.length;
		if (n > 0) {
			const step = n > 0 ? W / n : W;
			for (let j = 0; j < n; j++) {
				const v = rowVals[j];
				const a = CLAMP(v) / 127; // opacity 0..1 based on clamped value
				const x = j * step;
                const col = rowCols[j] || '#0ff';
                g += `<rect x='${x}' y='${y}' width='${Math.max(1, step - 1)}' height='${rowH}' fill='${col}' fill-opacity='${a}'></rect>`;
			}
		}
		y += rowH + GAP;
	}

	svg.style.height = `${Math.ceil(y)}px`;
	svg.innerHTML = g;
}

function collectSeed(frame) {
  const opens = ["loop", "ifg", "ifl"];      // tokens that own an `end`
  const first = frame.tokens[frame.idx++];   // grab the seed’s first token
  const block = [first];                     // start building the seed array
 
  // ---- NEW: decide if we need to collect a whole control block ----
  const [base] = splitTok(first);
  if (!opens.includes(base)) {
    // Plain literal / primitive / @call / branchN token – seed is just one token.
    return block;
  }

  // ---- Existing behaviour for real control blocks ----
  let depth = 1;
  while (frame.idx < frame.tokens.length && depth) {
    const t = frame.tokens[frame.idx++];
    const [b] = splitTok(t);
    if (opens.includes(b)) depth++;
    else if (t === "end")  depth--;
    block.push(t);
  }
  return block;
}


/******************** INTERPRETER *********************/
function runWithOutput(src, debug = false, opts = {}) {
	const dryRun = opts && opts.dryRun === true;
	const tokens = src.trim().split(/\s+/);
	// refresh LABELS: default everything to –1 (skip during dry runs)
	if (!dryRun) {
		for (const k in LABELS) LABELS[k] = -1;
		tokens.forEach((t, i) => {
		  const [, lab] = splitTok(t);
		  if (lab) LABELS[lab] = i;          // absolute offset in original token list
		});
	}
    let thisStep = 0;
	const functions = {};
	const main = parseDefs(tokens, functions);
	const threads = [{
		pc: 0,
    tokens: main,
    stack: [],
    callStack: [],
		blockStack: [],
		fn: ""
	}];
	const out = [],
		outHTML = [],
		vals = [],
		cols = [],
		tips = [];
	const palette = ["#ff0", "#f0f", "#0ff", "#f80", "#0f0", "#08f", "#f44", "#fff", "#ccc", "#faa"];

	function parseDefs(tok, table) {
    const body = [];
    let currentName = null;
    let currentLabel = null;
    let currentBody = [];
    let controlDepth = 0; // depth of nested control blocks inside a function

    for (let i = 0; i < tok.length; i++) {
        const tk = tok[i];
        if (!tk) continue;

        // New function declaration starts: implicit END of previous function (if any)
        if (tk.startsWith(">")) {
            const raw = tk.slice(1);
            const [name, lab] = splitTok(raw);
            if (currentName !== null) {
                table[currentName] = { body: currentBody, label: currentLabel };
            }
            currentName = name;
            currentLabel = lab;
            currentBody = [];
            controlDepth = 0;
            continue;
        }

        const [base] = splitTok(tk);

        if (currentName !== null) {
            // We are inside a function body
            if (base === "loop" || base === "ifg" || base === "ifl") {
                currentBody.push(tk);
                controlDepth += 1;
                continue;
            }
            if (tk === "end") {
                if (controlDepth > 0) {
                    // close an inner control block, not the function
                    currentBody.push(tk);
                    controlDepth -= 1;
                } else {
                    // close the function body
                    table[currentName] = { body: currentBody, label: currentLabel };
                    currentName = null;
                    currentLabel = null;
                    currentBody = [];
                    controlDepth = 0;
                }
                continue;
            }
            // any other token is part of the current function body
            currentBody.push(tk);
        } else {
            // Not inside a function: token belongs to main body
            body.push(tk);
        }
    }

    // If file ends while inside a function, implicitly close it
    if (currentName !== null) {
        table[currentName] = { body: currentBody, label: currentLabel };
    }

    return body;
}

	let inst = 0;
	while (threads.length && inst < MAX_INST) {
		for (let tid = 0; tid < threads.length && inst < MAX_INST; tid++) {
			const th = threads[tid],
				S = th.stack,
				pop = () => S.pop() ?? 0;
			let tok;
			// fetch token
			while (true) {
				if (th.blockStack.length) {
					const blk = th.blockStack[th.blockStack.length - 1];
					if (blk.idx < blk.tokens.length) {
						tok = blk.tokens[blk.idx++];
						break;
					}
					th.blockStack.pop();
                    if(blk.type==="func") th.callStack.pop();
		    if (blk.type === "loop" || blk.type === "once") th.callStack.pop();

                    if (blk.type === "loop" && --blk.remaining > 0) {
            		th.blockStack.push({
						...blk,
						idx: 0
						});
						th.callStack.push(blk.label || "LOOP"); 
					} else continue;
				} else {
					if (th.pc >= th.tokens.length) {
						threads.splice(tid, 1);
						tid--;
						tok = null;
						break;
					}
					tok = th.tokens[th.pc++];
					break;
				}
			}
			if (tok == null) continue;
			let [baseTok, labTok] = splitTok(tok);
			tok = baseTok;

			inst++;
			if (debug) console.log(`[T${tid}] ${tok} [${S.join(',')}]`);
			// primitives
			if (["+", "-", "*", "/", "dup", "swap", "drop", "out", "bit", "bval", "prune"].includes(tok)) {
				if (tok === "dup") S.push(S.at(-1) ?? 0);
				else if (tok === "swap") {
					let b = pop(),
						a = pop();
					S.push(b, a);
				} else if (tok === "drop") pop();
				else if (tok === "bit") bitCounter++;
				else if (tok === "bval") { S.push(bitCounter); bitCounter = 0; }
				else if (tok === "prune") {
					const v = pop();
					if (v<64) {
						 // terminate thread
						 threads.splice(tid,1); tid--; continue; 
					}
				}
				else if (tok === "out") {
				  let v;
				  if (bitCounter > 0) {
					v = bitCounter;
					bitCounter = 0;
				  } else {
					v = pop();
				  }
					out.push(v);
					const cs = th.callStack==null ? '' : th.callStack.join("|");
					const idx = Math.abs(hashCode(`${tid}-${cs}`)) % palette.length;
					outHTML.push(`<span style='color:${palette[idx]}' title='T${tid}${cs?" @"+cs:""}'>${v}</span>`);
					vals.push(v);
					cols.push(palette[idx]);
					tips.push(`T${tid}${cs?" @"+cs:""}`);
				} else {
					let b = pop(),
						a = pop(),
						r = 0;
					switch (tok) {
						case "+":
							r = a + b;
							break;
						case "-":
							r = a - b;
							break;
						case "*":
							r = a * b;
							break;
						case "/":
							r = b ? Math.trunc(a / b) : 0;
					}
					S.push(CLAMP(r));
				}
				continue;
			}
			// control blocks helper
			function collect(label, frame) {
				const blk = []; 
				let d = 1;
              const opens = ["loop", "ifg", "ifl"]; 
				while (frame.idx < frame.tokens.length && d) {
					const t = frame.tokens[frame.idx++];
					const [b] = splitTok(t);
					if (opens.includes(b)) d++;
					else if (t === "end") d--;
					if (d) blk.push(t);
				}
				return blk;
			}
			// current frame ref
			const frameRef = th.blockStack.length ? th.blockStack[th.blockStack.length - 1] : {
				tokens: th.tokens,
				idx: th.pc
			};

			if (tok === "loop" || tok === "ifg" || tok === "ifl") {
		                var startBeforeCollect = frameRef.idx - 1;
				const blk = collect(tok, frameRef);
				if (tok === "loop") {
					const n = pop();
					if (n > 0) {
					   th.blockStack.push({
						type: "loop",
						tokens: blk,
						idx: 0,
						remaining: n
		   		   }); 
					   th.callStack.push(labTok || "LOOP"); 
					}
				} else {
					const b = pop(),
						a = pop();
					const ok = (tok === "ifg" && b > a) || (tok === "ifl" && b < a);
					if (ok) {
						th.blockStack.push({
						type: "once",
						tokens: blk,
						idx: 0
		  				}); 
						th.callStack.push(labTok || tok.toUpperCase()); 
					}
				}
				 // Splice only once, at top level, so nested loops remain intact
				                 if (frameRef.tokens === th.tokens) {
                   const blkStart = startBeforeCollect;
                   const blkEnd   = frameRef.idx;          // idx after collect
                   frameRef.tokens.splice(blkStart, blkEnd - blkStart);
                   th.pc = blkStart;
                 }
				continue;
			}

			if (tok.startsWith("@")) {
                const name = tok.slice(1);
		  // --- Novelty Anchors ---
			if (name === "last") {
				// pop: first = which history (0 = most recent), second = index within selected history
				const historyIndexRaw = pop();
				const innerIndexRaw = pop();
				let val = 0;
				const hLen = outputHistory.length;
				if (hLen > 0) {
					const which = Math.abs(historyIndexRaw) % hLen;
					const selected = outputHistory.at(-1 - which) || [];
					if (selected.length > 0) {
						val = selected[Math.abs(innerIndexRaw) % selected.length] ?? 0;
					}
				}
				S.push(CLAMP(val));
				continue;
			}
		    	 if (name === "time") {
			    S.push(CLAMP(new Date().getSeconds()) % 10);
			    // we favor external inputs like random and time
			    inst = inst + ANCHOR_STEPS;
			    continue;
			  }
			  if (name === "random") {
			    S.push(CLAMP(Math.floor(Math.random() * 128)));
			    // we favor external inputs like random and time
			    inst = inst + ANCHOR_STEPS;
			    continue;
			  }		
                if (functions[name]) {
			  const fn = functions[name];
                  const p1 = pop(), p2 = pop(), p3 = pop();
                  S.push(p3, p2, p1);
                  th.blockStack.push({type:"func",tokens:[...fn.body],idx:0});
                  if (th.callStack==null) th.callStack = [];
                  th.callStack.push(fn.label || name);
                }
                continue;
              }

			if (tok.startsWith("branch") && tok.length === 7) {
				const N = +tok[6];
       			if (N >= 2 && N <= 5) {
       				const seeds = [];
                      const seedStartIndex = frameRef.idx;
                      
                  for (let i = 0; i < N; i++) {
                    seeds.push( collectSeed(frameRef) );     // collectSeed returns an array of tokens
                  }
const start = seedStartIndex;                // idx value you saved *before* the for-loop
const end   = frameRef.idx;                  // idx after collecting all N seeds
frameRef.tokens.splice(start, end - start);  // remove original seed tokens
frameRef.idx = start;
  const rest = frameRef.tokens.slice(frameRef.idx);
                    for (const seed of seeds) {
                      // deep-clone the *whole* thread
                      const clone = JSON.parse(JSON.stringify(th));   // or manual deep copy
                      const top   = clone.blockStack.length ? clone.blockStack[clone.blockStack.length - 1]
                                                          : { tokens: clone.tokens, idx: frameRef.idx };
                    top.tokens.splice(top.idx, 0, ...seed); 
                      clone.callStack = [...clone.callStack, `T${tid}`]; 
                      threads.push(clone);                            // new parallel thread
                    }

                  
				threads.splice(tid, 1);
				tid--;
			}
			continue;
		}

			const num = parseInt(tok, 10);
			if (!isNaN(num)) S.push(CLAMP(num));
		}
	}
		if (!dryRun) document.getElementById("output").innerHTML = "Output: " + outHTML.join(" ");
	const { len, cc, lastCount } = getMetrics(tokens);
    stepCount = inst;
  if (!dryRun) updateMetricsView(len, cc, lastCount);
  if (!dryRun) drawGraph(vals, cols, tips);
  if (!dryRun) updateLabelsView();  
	// Append this run's output to rolling history (cap at 20, 0 = most recent)
  if (!dryRun) {
 	outputHistory.push([...out]);
 	outputInertia.push(inertiaVal || 0);
  outputColorHistory.push([...cols]);
  outputTitleHistory.push([...tips]);
 	if (outputHistory.length > 20) outputHistory.shift();
 	if (outputInertia.length > 20) outputInertia.shift();
    if (outputColorHistory.length > 20) outputColorHistory.shift();
    if (outputTitleHistory.length > 20) outputTitleHistory.shift();
  }
	return out.join(" ");
}

/******************** UI *********************/
const savedPrograms = [];

function runProgram(d = false) {
	const code = document.getElementById("program").value.trim();
	runWithOutput(code, d);
}

function saveProgram() {
	const c = document.getElementById("program").value.trim();
	const url = new URL(window.location.href);
	url.search = ""; // remove existing query
	url.hash = "";   // remove hash
	url.searchParams.set("cost", c); // URLSearchParams handles encoding
	const urlStr = url.toString();

	function fallbackCopy() {
		try {
			const ta = document.createElement("textarea");
			ta.value = urlStr;
			document.body.appendChild(ta);
			ta.select();
			document.execCommand("copy");
			document.body.removeChild(ta);
			alert("Shareable link copied to clipboard.");
		} catch (e) {
			prompt("Copy this URL:", urlStr);
		}
	}

	if (navigator.clipboard && navigator.clipboard.writeText) {
		navigator.clipboard.writeText(urlStr)
			.then(() => alert("Shareable link copied to clipboard."))
			.catch(() => fallbackCopy());
	} else {
		fallbackCopy();
	}
}

function clearSavedPrograms() {
	mutCount = 0;
	updateMutCount();
	LABELS = { };
	savedPrograms.length = 0;
    document.getElementById("savedList").innerHTML = "";
}
function mutateProgram() {
  const orig = document.getElementById("program").value.trim();
  if (!orig) return;

  const toks = orig.split(/\s+/);

  const protected = new Set();
  let depth = 0;
  for (let i = 0; i < toks.length; i++) {
	  if (toks[i] === "[") depth++;
	  if (depth) protected.add(i); // mark anything inside
	  if (toks[i] === "]") 
	      depth--;
  }
  
  // Build list of indices that are actually safe to mutate
  const mutableIndices = [];
  for (let i = 0; i < toks.length; i++) {
    if (!protected.has(i) ) {
      mutableIndices.push(i);
    }
  }
  if (mutableIndices.length === 0) {
    alert("No mutable tokens available (all protected or special).");
    return;
  }
  
  const origLen = toks.length;
  const origOut = runWithOutput(orig, false, {dryRun:true});
  const origStep = stepCount;
  const maxStepDelta = Math.ceil(origStep * 0.05); // 5% margin on steps
  const maxAttemptsPerDelta = 500;

  let deltaTokens = 1;
  let totalAttempts = 0; // count how many mutation attempts are needed until one is accepted

  while (deltaTokens <= mutableIndices.length) {
    for (let attempt = 0; attempt < maxAttemptsPerDelta; attempt++) {
      let mut = [...toks];
      const indices = new Set();
      const targetCount = Math.min(deltaTokens, mutableIndices.length);
      while (indices.size < targetCount) {
        const idx = mutableIndices[Math.floor(Math.random() * mutableIndices.length)];
        indices.add(idx);
      }
      let involvesCommand = false;
      for (const idx of indices) {
	let newTok;
        let oldTok = mut[idx];
        do {
          newTok = randToken();
        } while (newTok === oldTok);
        if (isCommandToken(oldTok) || isCommandToken(newTok)) involvesCommand = true;
        mut[idx] = newTok;
      }
      // Ensure at least one mutated position involves a command
      if (!involvesCommand) {
        const forceIdx = Array.from(indices)[Math.floor(Math.random() * indices.size)];
        let forced;
        do {
          forced = randNonNumberToken();
        } while (forced === toks[forceIdx]);
        mut[forceIdx] = forced;
        involvesCommand = true;
      }

      const newCode = mut.join(" ");
      totalAttempts++;
      inertiaVal = totalAttempts;
      const newOut = runWithOutput(newCode, false, {dryRun:true});
      const newStep = stepCount;
 
      if (
        Math.abs(newStep - (targetSteps==0 ? origStep : targetSteps)) <= maxStepDelta &&
        newOut !== origOut &&
        mut.length === origLen
      ) {
        // Record inertia as attempts needed until an accepted mutation
        inertiaVal = totalAttempts;
        inertiaHist.push(inertiaVal);
        if (inertiaHist.length > INERTIA_WINDOW) inertiaHist.shift();
        updateInertia();

        document.getElementById("program").value = newCode;
        runProgram();
        return;
      }
    }
    deltaTokens++;
  }

  // No acceptable mutation found: record the inertia as total attempts tried
  inertiaVal = totalAttempts;
  inertiaHist.push(inertiaVal);
  if (inertiaHist.length > INERTIA_WINDOW) inertiaHist.shift();
  updateInertia();

  alert("No acceptable mutation found within constraints.");
}

// --- Perturbation Index helpers ---
function computeSingleInertiaAttemptForCode(codeStr, deadlineTimeMs) {
  if (!codeStr) return null;
  const toks = codeStr.trim().split(/\s+/);
  const protectedSet = new Set();
  let depth = 0;
  for (let i = 0; i < toks.length; i++) {
    if (toks[i] === "[") depth++;
    if (depth) protectedSet.add(i);
    if (toks[i] === "]") depth--;
  }
  const mutableIndices = [];
  for (let i = 0; i < toks.length; i++) {
    if (!protectedSet.has(i)) mutableIndices.push(i);
  }
  if (mutableIndices.length === 0) return null;

  const origLen = toks.length;
  const origOut = runWithOutput(codeStr, false, { dryRun: true });
  const origStep = stepCount;
  const maxStepDelta = Math.ceil(origStep * 0.05);
  const maxAttemptsPerDelta = 500;

  let deltaTokens = 1;
  let totalAttempts = 0;
  const hasDeadline = typeof deadlineTimeMs === 'number' && isFinite(deadlineTimeMs);

  while (deltaTokens <= mutableIndices.length) {
    for (let attempt = 0; attempt < maxAttemptsPerDelta; attempt++) {
      if (hasDeadline && Date.now() >= deadlineTimeMs) return totalAttempts;
      const mut = [...toks];
      const indices = new Set();
      const targetCount = Math.min(deltaTokens, mutableIndices.length);
      while (indices.size < targetCount) {
        const idx = mutableIndices[Math.floor(Math.random() * mutableIndices.length)];
        indices.add(idx);
      }
      let involvesCommand = false;
      for (const idx of indices) {
        let newTok;
        const oldTok = mut[idx];
        do {
          newTok = randToken();
        } while (newTok === oldTok);
        if (isCommandToken(oldTok) || isCommandToken(newTok)) involvesCommand = true;
        mut[idx] = newTok;
      }
      if (!involvesCommand) {
        const forceIdx = Array.from(indices)[Math.floor(Math.random() * indices.size)];
        let forced;
        do {
          forced = randNonNumberToken();
        } while (forced === toks[forceIdx]);
        mut[forceIdx] = forced;
        involvesCommand = true;
      }

      const newCode = mut.join(" ");
      totalAttempts++;
      if (hasDeadline && Date.now() >= deadlineTimeMs) return totalAttempts;
      const newOut = runWithOutput(newCode, false, { dryRun: true });
      const newStep = stepCount;

      if (
        Math.abs(newStep - (targetSteps==0 ? origStep : targetSteps)) <= maxStepDelta &&
        newOut !== origOut &&
        mut.length === origLen
      ) {
        return totalAttempts;
      }
    }
    deltaTokens++;
  }
  return totalAttempts;
}

function averageInertiaForCode(codeStr, trials, deadlineTimeMs) {
  let sum = 0;
  let count = 0;
  const hasDeadline = typeof deadlineTimeMs === 'number' && isFinite(deadlineTimeMs);
  for (let i = 0; i < trials; i++) {
    if (hasDeadline && Date.now() >= deadlineTimeMs) break;
    const val = computeSingleInertiaAttemptForCode(codeStr, deadlineTimeMs);
    if (val == null) return null;
    sum += val;
    count++;
  }
  const minNeeded = Math.min(PI_MIN_TRIALS, trials);
  if (count < minNeeded) return null;
  return sum / count;
}

function computePerturbationIndex() {
  const ta = document.getElementById('program');
  const originalText = ta.value;
  const selStart = ta.selectionStart;
  const selEnd = ta.selectionEnd;
  if (selStart == null || selEnd == null || selStart === selEnd) {
    alert('Select part of the program text first.');
    return;
  }

  // Preserve globals touched by dry runs and UI state
  const prevStepCount = stepCount;
  const prevTargetSteps = targetSteps;
  const prevBitCounter = bitCounter;

  // Build token list and character spans for selection mapping
  const tokens = [];
  const spans = [];
  const re = /\S+/g;
  let m;
  while ((m = re.exec(originalText)) !== null) {
    tokens.push(m[0]);
    spans.push({ start: m.index, end: m.index + m[0].length });
  }

  // Identify which token indices overlap the selection
  const selectedTokenIndices = [];
  for (let i = 0; i < spans.length; i++) {
    const s = spans[i].start;
    const e = spans[i].end;
    if (s < selEnd && e > selStart) selectedTokenIndices.push(i);
  }
  if (selectedTokenIndices.length === 0) {
    alert('No whole tokens found in the selection.');
    return;
  }

  // Original cost (length * steps)
  runWithOutput(originalText, false, { dryRun: true });
  const originalLen = tokens.length;
  const originalSteps = stepCount;
  const originalCost = originalLen * originalSteps;

  // Perform N mutations restricted to the selected tokens and average the total cost
  let sumCost = 0;
  for (let i = 0; i < PERTURBATION_RUNS; i++) {
    const mutated = tokens.slice();
    const idx = selectedTokenIndices[Math.floor(Math.random() * selectedTokenIndices.length)];
    const oldTok = mutated[idx];
    let newTok;
    do {
      newTok = randToken();
    } while (newTok === oldTok);
    mutated[idx] = newTok;

    const mutatedText = mutated.join(' ');
    runWithOutput(mutatedText, false, { dryRun: true });
    const steps = stepCount;
    const len = mutated.length;
    sumCost += len * steps;
  }

  const avgCost = sumCost / PERTURBATION_RUNS;
  const percent = (originalCost > 0 ? (avgCost / originalCost) * 100 : 0) - 100;
  const delta = avgCost - originalCost;

  // Restore globals possibly touched by dry runs
  stepCount = prevStepCount;
  targetSteps = prevTargetSteps;
  bitCounter = prevBitCounter;

  // Restore original text and selection (text was never changed, but selection UX matters)
  ta.value = originalText;
  try { ta.setSelectionRange(selStart, selEnd); } catch (e) {}

  alert(`${percent.toFixed(2)}% (${Math.abs(delta).toFixed(2)})`);
}

function computeSelectedCost() {
  const ta = document.getElementById('program');
  const originalText = ta.value;
  const selStart = ta.selectionStart;
  const selEnd = ta.selectionEnd;
  if (selStart == null || selEnd == null || selStart === selEnd) {
    alert('Select part of the program text first.');
    return;
  }

  const prevStepCount = stepCount;
  const prevTargetSteps = targetSteps;
  const prevBitCounter = bitCounter;

  const countTokens = (text) => {
    const trimmed = text.trim();
    if (!trimmed) return 0;
    return trimmed.split(/\s+/).length;
  };

  const replaceTokensWithNopInRange = (text, start, end) => {
    const re = /\S+/g;
    let out = '';
    let last = 0;
    let replaced = 0;
    let m;
    while ((m = re.exec(text)) !== null) {
      const s = m.index;
      const e = s + m[0].length;
      const overlaps = s < end && e > start;
      if (overlaps) {
        out += text.slice(last, s) + 'nop';
        last = e;
        replaced++;
      }
    }
    out += text.slice(last);
    return { text: out, replacedCount: replaced };
  };

  // Total cost (original)
  runWithOutput(originalText, false, { dryRun: true });
  const totalSteps = stepCount;
  const totalLen = countTokens(originalText);
  const totalCost = totalLen * totalSteps;

  // NOP-replaced selection cost
  const { text: noppedText, replacedCount } = replaceTokensWithNopInRange(originalText, selStart, selEnd);
  if (replacedCount === 0) {
    stepCount = prevStepCount; targetSteps = prevTargetSteps; bitCounter = prevBitCounter;
    alert('No whole tokens found in the selection.');
    return;
  }
  runWithOutput(noppedText, false, { dryRun: true });
  const noppedSteps = stepCount;
  const noppedLen = countTokens(noppedText);
  const noppedCost = noppedLen * noppedSteps;

  // Restore globals possibly touched by dry runs
  stepCount = prevStepCount;
  targetSteps = prevTargetSteps;
  bitCounter = prevBitCounter;

  if (totalCost <= 0) {
    alert('0.00%');
    return;
  }
  const selectionCost = totalCost - noppedCost;
  const percent = (selectionCost / totalCost) * 100;
  alert(percent.toFixed(2) + '%');
}


window.onload = () => {
	const sp = new URLSearchParams(location.search);
	const raw = sp.get("cost") || sp.get("code");
	if (raw) {
		document.getElementById("program").value = raw;
		setTimeout(runProgram, 0);
	}
	updateMutCount();   // initialise counter to 0 on first load
};
</script> 
</body> 
</html>
